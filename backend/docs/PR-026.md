# PR-026 — Rankings v2 (Sorting, Pagination, Caching)

## Goal

Upgrade `/api/rankings` to support:

* Multiple sorting modes
* Server-side pagination
* Deterministic ordering
* Short-TTL caching of full ranking result

This endpoint becomes the canonical market scanning endpoint.

---

# Endpoint Contract

## Request

```
GET /api/rankings?
    timeframe=1h
    sort=total
    page=1
    pageSize=30
```

## Query Parameters

### Required

* `timeframe`

### Optional

* `sort` (default = `total`)
* `page` (default = 1)
* `pageSize` (default = 30)

---

# Supported Sort Modes

| Sort Key | Meaning              |
| -------- | -------------------- |
| total    | TotalScore (default) |
| gain     | Gain/Loss score      |
| sideways | Sideways Consistency |
| trend    | Trend Predictability |
| volume   | 24h quote volume     |

Future-safe: unknown sort → fallback to `total`

---

# Pagination Rules

* `page >= 1`
* `pageSize >= 1`
* Default pageSize: 30
* Max pageSize: 100

Clamp at request validation stage.

Pagination must be applied AFTER sorting.

---

# Response

```json
{
  "timeframe": "1h",
  "sort": "total",
  "page": 1,
  "pageSize": 30,
  "totalItems": 200,
  "totalPages": 7,
  "results": [
    {
      "symbol": "BTCUSDT",
      "totalScore": 0.82,
      "scores": {
        "Gain/Loss": 0.75,
        "Sideways Consistency": 0.04,
        "Trend Predictability": 0.03
      },
      "volume": 1234567890.12
    }
  ]
}
```

Notes:

* `totalItems` = full ranked universe size
* `totalPages` = ceil(totalItems / pageSize)
* `volume` included for client-side display only (not sorting responsibility)

---

# Architectural Principle

Sorting must always happen on FULL ranked dataset before pagination.

Never:

* Fetch partial data
* Then sort
* Then paginate

Correct flow:

1. Resolve universe
2. Compute ranking scores for ALL symbols
3. Sort entire result by selected mode
4. Cache full sorted result
5. Apply pagination slice
6. Return page

---

# Caching Strategy

## What To Cache

Cache FULL sorted ranking result per:

```
rankings:{timeframe}:{sort}
```

Example:

```
rankings:1h:total
rankings:1h:sideways
```

Do NOT cache paginated slices.

Reason:

* Avoid duplicate keys
* Avoid cache explosion
* Pagination becomes cheap array slicing

---

## TTL Strategy

Recommended TTL: 60 seconds

Environment variable:

```
RANKINGS_CACHE_TTL_SECONDS=60
```

Clamp at startup:

* Min: 10 seconds
* Max: 300 seconds

---

# Execution Flow

## On Request

1. Validate query parameters
2. Generate cache key (timeframe + sort)
3. Attempt Redis GET

### If cache hit:

* Deserialize full ranking list
* Slice for requested page
* Return

### If cache miss:

* Compute full ranking
* Sort
* Store full list in Redis with TTL
* Slice for requested page
* Return

---

# Concurrency & Performance

Ranking computation already depends on:

* Volume data (cached)
* Candle data (likely cached)

Universe typically limited to 200–300 symbols.

Sorting 300 items is trivial.

Expected behavior under load:

* First request per TTL window computes
* Subsequent requests are <5ms

---

# Determinism Rules

For any sort mode:

Primary sort: selected metric (descending)
Secondary sort: symbol alphabetical (ascending)

This ensures stable ordering across requests.

---

# Error Handling

* Invalid timeframe → 400
* Invalid page/pageSize → clamp
* Empty universe → return empty results with totalItems=0
* Redis failure → fallback to compute

---

# Interface Changes

Update ranking use case:

```go
type GetRankings struct {
    universe     SymbolUniverseProvider
    scorer       SymbolScorer
    volumeSource VolumeProvider
    cacheTTL     time.Duration
}
```

Handler layer handles pagination slicing.

---

# Acceptance Criteria

* Supports multiple sort modes
* Pagination works correctly
* Sorting applied before pagination
* Cache hit significantly reduces latency
* Deterministic order across requests
* Page 20 does not trigger recomputation if cached

---

# Product Impact

This endpoint now supports:

* Infinite scroll (frontend-driven via page increment)
* Sort switching
* Stable pagination
* Large dataset browsing

It becomes the backbone of the scanner UI.

---

# Future Enhancements

* Singleflight stampede protection
* Separate TTL per timeframe
* Cursor-based pagination (if universe grows >1000)
* Filter parameters (min volume, min score)

---

# Final Principle

Ranking remains a backend concern.
Pagination and sorting remain server-side.
Frontend only requests pages and renders results.

This keeps performance, consistency, and scalability under control.
