# PR-013 — RankSymbols Use Case

## Goal

Introduce a **pure application-layer use case** responsible for ranking symbols based on composed scoring heuristics.

This PR wires together previously defined `SymbolScoreCalculator`s without introducing new domain logic.

---

## Scope

**Included**

* `RankSymbols` use case interface
* Default implementation composing multiple score calculators
* Explicit weighting configuration
* Deterministic sorting logic
* Tests as specification

**Explicitly Excluded**

* HTTP / API adapters
* Persistence or caching
* UI-facing DTOs
* Any new scoring heuristics

---

## Design Principles

* Orchestration only — no math here
* Open for extension, closed for modification
* Weighting must be explicit and configurable
* Stable, deterministic ordering

---

## Use Case Interface

```go
// RankSymbols ranks symbols based on configured scoring strategies.
type RankSymbols interface {
    Rank(series map[Symbol]CandleSeries) ([]RankedSymbol, error)
}
```

---

## Supporting Types

```go
type RankedSymbol struct {
    Symbol Symbol
    Scores map[string]float64
    TotalScore float64
}
```

Rules:

* `Scores` key is `SymbolScoreCalculator.Name()`
* `TotalScore` is weighted sum of individual scores

---

## Weight Configuration

```go
type ScoreWeight struct {
    Calculator SymbolScoreCalculator
    Weight     float64
}
```

Rules:

* Weight range is not enforced (tests define behavior)
* Zero-weight calculators are ignored
* Order of weights does not affect outcome

---

## Ranking Algorithm

1. For each symbol:

   * Execute all calculators
   * Collect named scores
2. Compute:

```
TotalScore = Σ(score_i × weight_i)
```

3. Sort symbols by:

   1. `TotalScore` (descending)
   2. Symbol name (ascending, tie-breaker)

---

## Error Handling

* If any calculator errors → use case errors
* Empty input → empty result, no error

---

## Test Strategy

Tests define ranking semantics.

### Required Tests

* Single calculator, uniform weight
* Multiple calculators with different weights
* Conflicting scores (one positive, one negative)
* Deterministic ordering with equal scores
* Ignoring zero-weight calculators

### Test Data

* Use stub calculators returning fixed values
* Do not depend on real CandleSeries behavior

---

## Acceptance Criteria

PR-013 is complete when:

* RankSymbols interface exists
* Default implementation composes calculators correctly
* Weighting and sorting are deterministic
* Tests clearly express ranking intent
* No domain or infra code is modified

---

## Follow-ups

* **PR-014** — Expose ranking via API
* **PR-015** — Frontend sorting & filters

---

## Non-Goals

* Dynamic weighting
* User-defined formulas
* Persistence of rankings

This PR defines *how intelligence is combined*, not how it is computed.
