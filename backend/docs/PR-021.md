# PR-021 — Redis Caching for ExchangeInfo

## Goal

Introduce a Redis-based caching decorator for the symbol universe provider to reduce external Binance API calls and protect against rate limits.

This PR caches the result of `BinanceExchangeInfoUniverse.Symbols()`.

No changes are made to the application layer.

---

## Motivation

The Binance `exchangeInfo` endpoint:

* Is relatively stable
* Changes infrequently
* Should not be fetched on every request

Without caching:

* Each `/api/rankings` call may trigger external HTTP calls
* Risk of rate limits increases
* Latency increases

With Redis caching:

* Reduced API pressure
* Faster rankings endpoint
* Better free-tier safety

---

## Scope

### Included

* Redis decorator for `SymbolUniverseProvider`
* Configurable TTL
* JSON serialization of symbol list
* Cache key namespacing
* Graceful fallback on cache miss

### Excluded

* Caching of ticker/volume data (future PR)
* Distributed cache invalidation
* Metrics integration

---

## Architecture

We introduce a decorator in infrastructure:

```
infrastructure/symbol_universe/
    redis_cached_universe.go
```

The decorator wraps any `SymbolUniverseProvider`.

---

## Decorator Design

```go
type RedisCachedSymbolUniverse struct {
    next SymbolUniverseProvider
    redis RedisClient
    ttl   time.Duration
    key   string
}
```

Where:

* `next` → underlying provider (e.g., BinanceExchangeInfoUniverse)
* `redis` → injected Redis client interface
* `ttl` → configurable duration (e.g., 10m–1h)
* `key` → e.g., "symbol_universe:exchange_info"

---

## Behavior

### On `Symbols(ctx)`:

1. Attempt `GET key` from Redis
2. If hit:

   * Deserialize JSON
   * Return symbols
3. If miss:

   * Call `next.Symbols(ctx)`
   * Serialize to JSON
   * Store with TTL
   * Return result

---

## Error Handling

* Redis failure → log and fallback to `next`
* JSON unmarshal failure → treat as cache miss
* Underlying provider error → return error

Never fail purely because Redis failed.

---

## Serialization Format

Store as:

```json
["BTCUSDT","ETHUSDT","BNBUSDT"]
```

Simple string slice for minimal overhead.

---

## Redis Interface

Use existing Redis abstraction from PR-009.

Expected minimal interface:

```go
type RedisClient interface {
    Get(ctx context.Context, key string) (string, error)
    Set(ctx context.Context, key string, value string, ttl time.Duration) error
}
```

---

## Tests

Location:

```
test/infrastructure/symbol_universe/
```

Use a fake in-memory Redis implementation.

### Required Test Cases

1. ReturnsCachedValueWhenPresent
2. CallsNextOnCacheMiss
3. StoresValueWithTTL
4. FallsBackWhenRedisFails
5. DoesNotCacheOnNextError

All tests deterministic, no real Redis.

---

## Wiring

In `main.go`:

```go
baseUniverse := NewBinanceExchangeInfoUniverse(...)

cachedUniverse := NewRedisCachedSymbolUniverse(
    baseUniverse,
    redisClient,
    30*time.Minute,
    "symbol_universe:exchange_info",
)
```

Application layer continues receiving `SymbolUniverseProvider`.

---

## Acceptance Criteria

* External calls to Binance significantly reduced
* `/api/rankings` latency improves after first request
* Redis failure does not break endpoint
* Tests cover cache hit and miss paths

---

## Future Enhancements

* Separate cache keys per quote asset
* Cache versioning strategy
* Metrics instrumentation
* Cache warmup on service start

---

## Notes

This PR strengthens production-readiness while keeping the architecture clean.

It follows the decorator pattern already established in PR-009.
