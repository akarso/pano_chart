# PR-020 — Volume-Based Universe Sorting

## Goal

Enhance the Binance symbol universe by sorting symbols based on 24h trading volume, ensuring the most liquid and relevant markets are prioritized.

This significantly improves ranking quality, overview usefulness, and API efficiency by focusing on actively traded pairs.

---

## Motivation

Alphabetical sorting (PR-019) ensures determinism but has no market meaning.

Volume-based ordering:

* Prioritizes liquidity
* Reduces noise from illiquid tokens
* Improves sideways/trend scoring stability
* Matches trader expectations ("top markets first")

This is a functional upgrade, not just cosmetic sorting.

---

## Scope

### Included

* Fetch 24h ticker statistics from Binance
* Sort filtered USDT symbols by descending 24h quote volume
* Apply limit AFTER sorting
* Deterministic secondary alphabetical sort (tie-breaker)
* Full unit test coverage with mocked HTTP responses

### Excluded

* Multi-exchange aggregation
* Persistent storage
* Redis caching (future PR)

---

## Binance Endpoint Used

```
GET https://api.binance.com/api/v3/ticker/24hr
```

This returns statistics for all symbols.

Relevant fields:

* `symbol`
* `quoteVolume`

We use `quoteVolume` (USDT-based volume comparison consistency).

---

## Updated Architecture

We extend the existing provider rather than replacing it.

Option A (Preferred):

```
BinanceExchangeInfoUniverse
        +
Binance24hTickerVolumeFetcher
        ↓
VolumeSortedBinanceUniverse
```

This keeps responsibilities separate:

* ExchangeInfo → discover valid symbols
* 24hrTicker → fetch volumes
* Universe → compose & sort

---

## Proposed Implementation

### New Interface (optional, cleanest design)

```
type VolumeProvider interface {
    Volumes(ctx context.Context) (map[string]float64, error)
}
```

Infrastructure implementation:

```
Binance24hTickerVolumeProvider
```

---

### Sorting Logic

Steps:

1. Fetch valid USDT symbols (from PR-019 provider)
2. Fetch 24h volumes
3. Match volumes by symbol
4. Exclude symbols without volume data
5. Sort by:

   * Descending volume
   * Alphabetical symbol (tie-breaker)
6. Apply limit

---

## Edge Case Handling

* Missing volume → symbol excluded
* Invalid numeric volume → skip symbol
* Network error → return error
* Empty response → return empty list

No silent fallbacks.

---

## Tests

Location:

```
test/infrastructure/symbol_universe/
```

### Required Test Cases

1. SortsByDescendingVolume
2. AppliesLimitAfterSorting
3. UsesAlphabeticalTieBreaker
4. ExcludesSymbolsWithoutVolume
5. ReturnsErrorOnTickerFailure
6. DeterministicAcrossMultipleCalls

Use httptest.Server to simulate both endpoints.

---

## Performance Considerations

* Binance ticker endpoint returns all symbols (~2000 entries)
* One additional HTTP call per universe resolution
* Acceptable for MVP

Future PR:

* Redis cache decorator for volume data
* Rate-limit aware caching

---

## Wiring

In main.go:

```
exchangeInfoProvider := NewBinanceExchangeInfoUniverse(...)
volumeProvider := NewBinance24hTickerVolumeProvider(...)

universe := NewVolumeSortedBinanceUniverse(
    exchangeInfoProvider,
    volumeProvider,
    limit,
)
```

---

## Acceptance Criteria

* `/api/rankings` prioritizes most liquid USDT pairs
* Deterministic ordering
* No changes required in application layer
* All tests pass without network access

---

## Future Enhancements

* Filter by minimum volume threshold
* Allow configurable sorting metric (volume, volatility, etc.)
* Cache ticker results in Redis

---

## Notes

This PR transforms the symbol universe from "static list" to "market-aware selection engine" while preserving clean architecture boundaries.

It is a major quality upgrade for overview scanning.
