# PR-018 — Symbol Universe (MVP)

## Goal

Introduce an explicit, deterministic **Symbol Universe** used by ranking and overview use cases.
This PR removes implicit or hard‑coded symbol selection from handlers/use cases and replaces it with a clear abstraction.

This is an MVP‑grade implementation: **static, predictable, zero external calls**.

---

## Scope

**Included**

* SymbolUniverseProvider interface (application layer)
* Static Binance Top‑N implementation (hardcoded list)
* Wiring into RankSymbols use case
* Tests proving deterministic ordering and size

**Explicitly Excluded**

* Dynamic discovery (Binance exchangeInfo, volume sorting)
* Persistence or caching
* HTTP endpoints for listing symbols
* Frontend changes

---

## Motivation

Ranking and overview screens require a well‑defined set of symbols.

Previously:

* Symbol selection was implicit or handler‑local
* Rankings could not be reasoned about or tested cleanly

After this PR:

* Symbol universe is explicit, injectable, testable
* Future providers (Binance API, CoinGecko, paid tiers) can be added without touching ranking logic

---

## Design

### Interface

Location:

```
lib/application/symbol_universe/
```

```go
type SymbolUniverseProvider interface {
    Symbols(ctx context.Context) ([]domain.Symbol, error)
}
```

---

### Static Implementation (MVP)

```go
type StaticBinanceTop30Universe struct {
    symbols []domain.Symbol
}
```

* Symbols are hardcoded at construction
* Order is stable
* Size is fixed (e.g. 30)

Example symbols (illustrative):

```
BTCUSDT, ETHUSDT, BNBUSDT, SOLUSDT, XRPUSDT, ADAUSDT, DOGEUSDT, ...
```

---

### Wiring

#### RankSymbols Use Case

Before:

* Symbols inferred or locally defined

After:

* Symbols resolved via SymbolUniverseProvider

```go
symbols, err := universeProvider.Symbols(ctx)
```

The use case:

* Does NOT care where symbols come from
* Only iterates over provided list

---

## Tests

### Location

```
test/application/symbol_universe/
```

### Tests to Implement

1. **ReturnsConfiguredSymbols**

   * Asserts returned symbols match constructor input

2. **OrderIsStable**

   * Multiple calls return symbols in identical order

3. **EmptyUniverseIsAllowed**

   * Returns empty slice without error

---

## Acceptance Criteria

* RankSymbols no longer contains any symbol selection logic
* Symbol universe is injectable and mockable
* Tests pass without network access
* No changes to HTTP or domain scoring logic

---

## Follow‑Ups

* PR‑019: BinanceExchangeInfoUniverse
* PR‑020: Volume‑based symbol ranking
* PR‑021: Configurable universe size per request

---

## Notes

This PR intentionally favors **clarity over cleverness**.
A static universe is sufficient for MVP validation and frontend development.
