# PR-023 — Overview Endpoint with Sparkline Aggregation

## Goal

Introduce a new endpoint:

```
GET /api/overview
```

This endpoint returns ranked symbols together with precomputed sparkline data (close prices only), allowing the frontend to render overview mini charts with a single request.

Sparkline precision (number of closes returned) must be configurable via constant or environment variable.

---

## Motivation

Current frontend flow would require:

* 1 call to `/api/rankings`
* N calls to `/api/v1/candles`

This is inefficient and increases latency.

The overview endpoint:

* Batches ranking + candle aggregation
* Reduces client complexity
* Reduces HTTP roundtrips
* Centralizes sparkline logic in backend

---

## Endpoint Contract

### Request

```
GET /api/overview?timeframe=1h&limit=10
```

### Response

```json
{
  "timeframe": "1h",
  "count": 10,
  "precision": 30,
  "results": [
    {
      "symbol": "BTCUSDT",
      "totalScore": 0.82,
      "sparkline": [
        42100.0,
        42210.5,
        42150.2
      ]
    }
  ]
}
```

Notes:

* `precision` indicates number of closes returned
* `sparkline` contains close prices only
* Array must be ordered chronologically (oldest → newest)

---

## Configurable Sparkline Precision

Define configurable precision:

Option A (recommended): Environment variable

```
OVERVIEW_SPARKLINE_PRECISION=30
```

Option B: Fallback constant

```go
const DefaultSparklinePrecision = 30
```

Load at application startup and inject into use case.

Rules:

* Must be > 0
* Should be capped (e.g., max 200)
* Default if invalid

---

## Architecture

New use case:

```
application/usecase/get_overview.go
```

Dependencies:

```go
type GetOverview struct {
    ranker           RankSymbolsUseCase
    candleProvider   CandleProvider
    precision        int
}
```

---

## Execution Flow

1. Call ranking use case
2. For each ranked symbol:

   * Fetch last `precision` candles
   * Extract close prices
3. Aggregate into overview DTO
4. Return response

---

## Candle Fetch Strategy

Important: Only fetch required candles.

Do NOT fetch arbitrary time range.

Instead:

* Calculate "now"
* Determine timeframe duration
* Fetch exactly `precision` recent candles

Example:
If timeframe = 1h and precision = 30 → fetch last 30 hours.

---

## Concurrency Strategy

Fetching candles sequentially for 10–30 symbols is slow.

Use bounded concurrency:

* Worker pool
* Or errgroup with limit
* Max concurrency (e.g., 5–10)

Prevent unbounded goroutines.

If one symbol fails:

* Skip symbol
* Continue others
* Do not fail entire overview unless all fail

---

## DTOs

### OverviewResult

```go
type OverviewResponse struct {
    Timeframe string
    Count     int
    Precision int
    Results   []OverviewSymbol
}
```

### OverviewSymbol

```go
type OverviewSymbol struct {
    Symbol     string
    TotalScore float64
    Sparkline  []float64
}
```

---

## Error Handling

* Ranking failure → return error
* Candle failure per symbol → skip symbol
* All symbols fail → return error

Never panic.

---

## Performance Expectations

For limit=10 and precision=30:

* 10 candle queries
* Each limited to 30 bars
* Acceptable latency < 500ms under normal conditions

Future optimization:

* Cache overview result
* Cache sparkline separately

---

## Acceptance Criteria

* `/api/overview` returns ranked symbols with sparkline
* Sparkline length equals configured precision
* Order is chronological
* Bounded concurrency used
* Invalid precision falls back to default
* Works with existing ranking + candle providers

---

## Future Enhancements

* Include mini volatility metric
* Include 24h change %
* Add optional `includeScores=true`
* Cache entire overview response (short TTL)

---

## Notes

This PR transforms backend from "ranking engine" to "dashboard-ready API".

After this, frontend implementation becomes straightforward and low-latency.
