# PR-022 — Redis Caching for 24h Volume Data

## Goal

Introduce Redis caching for Binance 24h ticker volume data used in PR-020 (Volume-Based Universe Sorting).

This reduces external API pressure, improves latency, and stabilizes rankings under load.

Application layer remains unchanged.

---

## Motivation

The Binance endpoint:

```
GET /api/v3/ticker/24hr
```

* Returns ~2000+ symbols
* Is called frequently if rankings endpoint is hit often
* Has stricter rate limits than `exchangeInfo`

Without caching:

* High external dependency risk
* Increased latency
* Risk of temporary rate bans

Volume data changes frequently but does not require per-request freshness.

---

## Scope

### Included

* Redis decorator for `VolumeProvider`
* Configurable TTL (shorter than exchangeInfo cache)
* JSON serialization of symbol→volume map
* Graceful Redis failure handling

### Excluded

* Distributed invalidation
* Partial symbol caching
* Streaming updates

---

## Architecture

Add decorator in:

```
infrastructure/symbol_universe/redis_cached_volume_provider.go
```

Wraps existing:

```
Binance24hTickerVolumeProvider
```

---

## Decorator Design

```go
type RedisCachedVolumeProvider struct {
    next   VolumeProvider
    redis  RedisClient
    ttl    time.Duration
    key    string
}
```

Where:

* `next` → Binance volume provider
* `redis` → injected Redis abstraction
* `ttl` → e.g. 1–5 minutes
* `key` → e.g. "binance:24h_volume"

---

## Behavior

### On `Volumes(ctx)`:

1. Attempt Redis GET
2. If hit:

   * Deserialize JSON into `map[string]float64`
   * Return map
3. If miss:

   * Call `next.Volumes(ctx)`
   * Serialize result
   * Store in Redis with TTL
   * Return result

---

## TTL Strategy

Recommended TTL: **2 minutes**

Reasoning:

* Volume changes continuously
* Rankings do not require second-level accuracy
* 2-minute window dramatically reduces API pressure

Allow TTL to be configurable.

---

## Serialization Format

Stored as JSON object:

```json
{
  "BTCUSDT": 1234567890.12,
  "ETHUSDT": 987654321.00
}
```

Simple map for minimal overhead.

---

## Error Handling

* Redis GET failure → log and fallback to `next`
* Redis SET failure → ignore, still return fresh data
* JSON unmarshal error → treat as cache miss
* Underlying provider error → return error (do not cache)

Redis must never break rankings endpoint.

---

## Tests

Location:

```
test/infrastructure/symbol_universe/
```

Use in-memory fake Redis.

### Required Test Cases

1. ReturnsCachedVolumesWhenPresent
2. CallsNextOnCacheMiss
3. StoresValueWithTTL
4. FallsBackOnRedisFailure
5. DoesNotCacheWhenNextFails
6. DeterministicDeserialization

No real Redis or network calls.

---

## Wiring

In `main.go`:

```go
volumeProvider := NewBinance24hTickerVolumeProvider(httpClient, baseURL)

cachedVolumeProvider := NewRedisCachedVolumeProvider(
    volumeProvider,
    redisClient,
    2*time.Minute,
    "binance:24h_volume",
)

universe := NewVolumeSortedBinanceUniverse(
    exchangeInfoProvider,
    cachedVolumeProvider,
    limit,
)
```

---

## Performance Impact

Before:

* 1 exchangeInfo call
* 1 ticker/24hr call per rankings request

After:

* ticker call only every TTL window
* Massive reduction in outbound traffic

---

## Acceptance Criteria

* Rankings endpoint does not hit Binance on every request
* Cache hit returns identical volume map
* Redis failure does not break endpoint
* Unit tests fully cover hit/miss paths

---

## Future Enhancements

* Separate cache keys per quote asset
* Warm cache on service startup
* Background refresh goroutine
* Metrics for hit/miss ratio

---

## Notes

Volume caching is more critical than exchangeInfo caching because ticker endpoint is called more frequently and returns significantly larger payloads.

This PR significantly improves production safety and scalability.
